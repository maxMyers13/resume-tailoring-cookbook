---
description: >-
  Show you can design endpoints, handle auth, move data, and ship UI that uses
  it.
---

# 1.2 Fullstack SWE

### **What to emphasize**

* REST or GraphQL design, auth, validation, rate limits
* SQL schema design or ORM usage, migrations, debugging
* Minimal front end to demonstrate the API in action

### Copy-paste prompts

#### Role Switcher

{% code overflow="wrap" %}
```prompt
SWITCH ROLE → Backend API / Fullstack
Priority: API surface quality, contract clarity, auth, validation, and DB modeling. Use the JD’s stack terms naturally. Keep bullets focused on endpoints, schema, and shipped behavior.
```
{% endcode %}

### Core Tailor Prompt

{% code overflow="wrap" %}
```prompt
Produce 2–3 Backend/Fullstack bullets aligned to the JD:
- Name 1–2 key endpoints and what they do.
- State the auth and validation approach.
- Mention the schema or ORM decisions.
- Add one metric (latency, throughput, errors reduced, admin time saved).

JD:
[Paste]

Experience:
[Paste role or project]
```
{% endcode %}

**Role micro‑prompts**

* “Add a concise endpoint example path and method.”
* “Add one DB tuning detail if true: index, query plan, or N+1 fix.”

### Fix weak bullets for this role

```prompt
Ask me:
1) How many endpoints, and which critical ones.
2) Auth method (JWT, sessions), roles, and validation strategy.
3) DB details: tables, indexes, migrations, queries affected.
4) Traffic or load used for testing; latency or throughput results.
5) Frontend integration proofs (screens, workflows, demo users).
Then write 2–3 bullets with one metric each.
```

### Examples

### Short patterns you can model

* Exposed user and report CRUD endpoints with Node.js and Sequelize, enforced server‑side validation and JWT roles, and added migrations to evolve the MySQL schema; cut manual admin steps by moving workflows into the dashboard.\
  \> TODO: add number of endpoints or requests per day.
* Built a Flask API for face‑based authentication using OpenCV, stored embeddings in PostgreSQL, and integrated with a React client; kept login false‑accepts low in testing.\
  TODO: add FAR/FRR and median login time.

### **Before→After examples**

#### _Before_

Built a login system with face detection.

#### _After_

Built a Flask API for face‑based login using OpenCV, implemented JWT role‑based access, and stored embeddings in PostgreSQL; reduced average login time while keeping false acceptances low.\
&#xNAN;_&#x54;ODO: add accuracy, latency, and user count._

#### _Before_

Created a full‑stack dashboard.

#### _After_

Shipped a full‑stack admin dashboard with React and Node.js exposing CRUD endpoints for users and reports, enforced server‑side validation and auth, and added Sequelize migrations to version the MySQL schema; cut manual admin tasks by moving workflows to self‑service UI.\
&#xNAN;_&#x54;ODO: add number of endpoints or usage data._

### Quick checklist

* 1 metric per bullet
* Mention at least one endpoint
* Show auth + validation detail
* Include one DB decision (schema, migration, index)
* One line, verb first, correct tense
